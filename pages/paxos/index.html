<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta name="color-scheme" content="dark" />
    <title>USDG Dashboard | rodiger</title>
    <link rel="apple-touch-icon" sizes="180x180" href="/static/favicon/apple-touch-icon.png" />
    <link rel="icon" type="image/png" sizes="32x32" href="/static/favicon/favicon-32x32.png" />
    <link rel="icon" type="image/png" sizes="16x16" href="/static/favicon/favicon-16x16.png" />
    <link rel="icon" type="image/x-icon" href="/static/favicon/favicon.ico" />
    <link rel="stylesheet" href="/static/css/style.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4/dist/chart.umd.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
    <style>
      .dashboard-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 1rem;
        margin: 1.5rem 0;
      }
      .metric-card {
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 1rem 1.2rem;
      }
      .metric-card .label {
        font-size: 0.75rem;
        color: var(--gray);
        text-transform: uppercase;
        letter-spacing: 0.05em;
        margin-bottom: 0.3rem;
      }
      .metric-card .value {
        font-size: 1.4rem;
        font-weight: 600;
        color: var(--fg);
      }
      .metric-card .delta {
        font-size: 0.78rem;
        margin-top: 0.2rem;
      }
      .delta.up { color: var(--green); }
      .delta.down { color: var(--red); }
      .delta.neutral { color: var(--gray); }
      .section {
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 0.5rem;
        padding: 1.2rem;
        margin: 1.5rem 0;
      }
      .section h3 { margin: 0 0 0.75rem; font-size: 1rem; }
      .section canvas { margin: 0; border-radius: 0; }
      .race-track {
        position: relative;
        height: 48px;
        background: var(--bg);
        border-radius: 6px;
        margin: 0.75rem 0;
        overflow: hidden;
      }
      .race-bar {
        position: absolute;
        top: 0; bottom: 0;
        border-radius: 6px;
        display: flex;
        align-items: center;
        padding: 0 12px;
        font-size: 0.8rem;
        font-weight: 600;
        transition: width 0.6s ease;
        white-space: nowrap;
      }
      .race-gap {
        text-align: center;
        font-size: 1.1rem;
        font-weight: 600;
        color: var(--h3);
        margin: 0.5rem 0 0;
      }
      .chain-bar {
        display: flex;
        align-items: center;
        margin: 0.5rem 0;
        gap: 0.75rem;
      }
      .chain-bar .chain-name {
        width: 100px;
        font-size: 0.82rem;
        text-align: right;
        color: var(--gray);
        flex-shrink: 0;
      }
      .chain-bar .bar-track {
        flex: 1;
        height: 28px;
        background: var(--bg);
        border-radius: 4px;
        overflow: hidden;
      }
      .chain-bar .bar-fill {
        height: 100%;
        border-radius: 4px;
        transition: width 0.6s ease;
      }
      .chain-bar .bar-meta {
        width: 140px;
        font-size: 0.78rem;
        color: var(--fg);
        flex-shrink: 0;
        text-align: right;
      }
      .chain-bar .bar-meta .chain-delta { font-size: 0.72rem; }
      .market-table { font-size: 0.82rem; }
      .market-table td:nth-child(n+2),
      .market-table th:nth-child(n+2) { text-align: right; }
      .highlight-row { background: rgba(122, 162, 247, 0.08); }
      .insight-callout {
        background: rgba(122, 162, 247, 0.06);
        border-left: 3px solid var(--h2);
        padding: 0.75rem 1rem;
        margin: 1rem 0;
        font-size: 0.85rem;
        color: var(--fg);
        border-radius: 0 4px 4px 0;
      }
      .insight-callout strong { color: var(--h3); }
      .global-controls {
        display: flex;
        gap: 1rem;
        align-items: center;
        flex-wrap: wrap;
        margin: 1rem 0 0.5rem;
      }
      .control-label {
        font-size: 0.75rem;
        color: var(--gray);
        text-transform: uppercase;
        letter-spacing: 0.05em;
      }
      .toggle-group {
        display: inline-flex;
        background: var(--bg2);
        border: 1px solid var(--border);
        border-radius: 4px;
        overflow: hidden;
      }
      .toggle-group button {
        background: none;
        border: none;
        color: var(--gray);
        font-family: inherit;
        font-size: 0.78rem;
        padding: 0.35rem 0.75rem;
        cursor: pointer;
        transition: all 0.15s;
      }
      .toggle-group button.active {
        background: var(--h2);
        color: var(--bg);
        font-weight: 600;
      }
      .toggle-group button:hover:not(.active) {
        color: var(--fg);
      }
      .updated-time {
        text-align: center;
        color: var(--gray);
        font-size: 0.78rem;
        margin-top: 2rem;
      }
      .two-col {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 1rem;
      }
      @media (max-width: 768px) {
        .two-col { grid-template-columns: 1fr; }
      }
    </style>
  </head>
  <body>
    <div class="container">
      <nav class="top">
        <a href="/" class="back" aria-label="Back to home">&larr; back</a>
      </nav>
      <main id="content">
        <h1>Paxos Stablecoin Dashboard</h1>
        <p style="color: var(--gray); margin-top: -0.5rem;">Growth metrics and market positioning. Live data from <a href="https://defillama.com" target="_blank">DefiLlama</a>.</p>

        <!-- Global controls -->
        <div class="global-controls">
          <span class="control-label">Asset:</span>
          <span class="toggle-group" id="asset-toggle">
            <button data-asset="usdg" class="active">USDG</button>
            <button data-asset="pyusd">PYUSD</button>
            <button data-asset="combined">USDG + PYUSD</button>
          </span>
          <span class="control-label" style="margin-left:0.5rem">Period:</span>
          <span class="toggle-group" id="period-toggle">
            <button data-period="7d">7d</button>
            <button data-period="30d" class="active">30d</button>
          </span>
        </div>

        <!-- Top metrics -->
        <div class="dashboard-grid" id="metrics-grid"></div>

        <!-- Insight -->
        <div id="insight-1" class="insight-callout" style="display:none"></div>

        <!-- Race to next rank -->
        <div class="section" id="race-section">
          <h3 style="color: var(--h3);">Race to Next Rank</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="race-subtitle"></p>
          <div class="race-track" id="race-track"></div>
          <div class="race-gap" id="race-gap"></div>
        </div>

        <!-- Supply chart -->
        <div class="section">
          <h3 style="color: var(--h3);">Supply Over Time</h3>
          <canvas id="supply-chart" height="260"></canvas>
        </div>

        <!-- Milestone velocity -->
        <div class="section">
          <h3 style="color: var(--h3);" id="milestone-title">Speed to $1B vs The Field</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.75rem">Days from first tracked supply to each milestone. Lower is faster.</p>
          <canvas id="milestone-chart" height="220"></canvas>
          <div id="milestone-insight" class="insight-callout" style="display:none;margin-top:1rem"></div>
        </div>

        <!-- Chain distribution -->
        <div class="section">
          <h3 style="color: var(--h3);">Chain Distribution &amp; Velocity</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="chain-subtitle"></p>
          <div id="chain-bars"></div>
          <div id="chain-insight" class="insight-callout" style="display:none;margin-top:0.75rem"></div>
        </div>

        <!-- Growth rate vs peers -->
        <div class="section">
          <h3 style="color: var(--h3);">Growth Rate vs Peers</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="growth-subtitle"></p>
          <canvas id="growth-chart" height="350"></canvas>
        </div>

        <!-- Alt-stable market share -->
        <div class="section">
          <h3 style="color: var(--h3);">Alt-Stable Market Share</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="alt-subtitle"></p>
          <div style="max-width:400px;margin:0 auto"><canvas id="alt-share-chart" height="250"></canvas></div>
        </div>

        <!-- Growth capture -->
        <div class="section">
          <h3 style="color: var(--h3);">Growth Capture</h3>
          <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="capture-subtitle"></p>
          <canvas id="capture-chart" height="250"></canvas>
          <div id="capture-insight" class="insight-callout" style="display:none;margin-top:0.75rem"></div>
        </div>

        <!-- On-chain metrics (Dune) -->
        <div id="dune-section" style="display:none">
          <h2 style="color: var(--h2); margin-top: 2rem;">On-Chain Metrics</h2>
          <p style="color: var(--gray); margin-top: -0.5rem; font-size: 0.82rem;">Live on-chain data from <a href="https://dune.com" target="_blank">Dune Analytics</a>. Updates daily. <span id="dune-updated-at"></span></p>

          <div class="dashboard-grid" id="dune-metrics-grid"></div>

          <!-- Transfer volume chart -->
          <div class="section">
            <h3 style="color: var(--h3);">Daily Transfer Volume (90d)</h3>
            <canvas id="volume-chart" height="260"></canvas>
          </div>

          <!-- Whale concentration -->
          <div class="section" id="whale-section">
            <h3 style="color: var(--h3);">Top Holder Concentration</h3>
            <p style="font-size:0.82rem;color:var(--gray);margin:0 0 0.5rem" id="whale-subtitle"></p>
            <canvas id="whale-chart" height="220"></canvas>
            <div id="whale-insight" class="insight-callout" style="display:none;margin-top:0.75rem"></div>
          </div>

          <!-- DEX liquidity -->
          <div class="section" id="dex-section">
            <h3 style="color: var(--h3);">DEX Trading Activity (30d)</h3>
            <div id="dex-bars"></div>
          </div>
        </div>

        <!-- Market table -->
        <div class="section">
          <h3 style="color: var(--h3);">Stablecoin Rankings</h3>
          <table class="market-table">
            <thead><tr><th>Stablecoin</th><th>Market Cap</th><th id="table-period-header">30d</th><th>Share</th></tr></thead>
            <tbody id="market-tbody"></tbody>
          </table>
        </div>

        <p class="updated-time" id="updated-time"></p>
      </main>
      <footer><p><a href="/">rodiger.io</a></p></footer>
    </div>

    <script>
const USDG_ID = '286';
const PYUSD_ID = '120';
const CHAIN_COLORS = {
  'Solana': '#9945FF', 'Ethereum': '#627EEA', 'X Layer': '#e0af68', 'Ink': '#f7768e',
  'Polygon': '#8247E5', 'Arbitrum': '#28A0F0', 'OP Mainnet': '#FF0420',
  'ZKsync Era': '#4E529A', 'Linea': '#61DFFF', 'Mantle': '#000',
};
const ASSET_COLORS = {
  usdg: '#7aa2f7', pyusd: '#bb9af7', combined: '#9ece6a',
};
const COMPARE_STABLES = { 'USDC': 2, 'USDe': 146 };

function fmt(n) {
  n = n || 0;
  if (Math.abs(n) >= 1e9) return '$' + (n / 1e9).toFixed(2) + 'B';
  if (Math.abs(n) >= 1e6) return '$' + (n / 1e6).toFixed(1) + 'M';
  if (Math.abs(n) >= 1e3) return '$' + (n / 1e3).toFixed(0) + 'K';
  return '$' + n.toFixed(0);
}
function pct(n) { n = n || 0; return (n >= 0 ? '+' : '') + n.toFixed(1) + '%'; }
function daysStr(n) { return n + (n === 1 ? ' day' : ' days'); }
async function fetchJSON(url) { return (await fetch(url)).json(); }

// Global state
let STATE = { asset: 'usdg', period: '30d' };
let DATA = {};

// Chart instances for cleanup
let charts = {};
function destroyChart(id) { if (charts[id]) { charts[id].destroy(); delete charts[id]; } }

async function main() {
  try {
    const [usdgDetail, pyusdDetail, allStables, usdgHistory, pyusdHistory, ...compareHistories] = await Promise.all([
      fetchJSON(`https://stablecoins.llama.fi/stablecoin/${USDG_ID}`),
      fetchJSON(`https://stablecoins.llama.fi/stablecoin/${PYUSD_ID}`),
      fetchJSON('https://stablecoins.llama.fi/stablecoins?includePrices=false'),
      fetchJSON(`https://stablecoins.llama.fi/stablecoincharts/all?stablecoin=${USDG_ID}`),
      fetchJSON(`https://stablecoins.llama.fi/stablecoincharts/all?stablecoin=${PYUSD_ID}`),
      ...Object.values(COMPARE_STABLES).map(id =>
        fetchJSON(`https://stablecoins.llama.fi/stablecoincharts/all?stablecoin=${id}`)
      ),
    ]);

    // Parse chain data for both assets
    function parseChains(detail) {
      const chains = {};
      for (const [chain, data] of Object.entries(detail.chainBalances || {})) {
        const tokens = data.tokens || [];
        if (tokens.length) {
          const c = tokens[tokens.length - 1].circulating.peggedUSD;
          chains[chain] = { current: c };
          if (tokens.length >= 30) chains[chain].prev30 = tokens[tokens.length - 30].circulating.peggedUSD;
          if (tokens.length >= 7) chains[chain].prev7 = tokens[tokens.length - 7].circulating.peggedUSD;
        }
      }
      return chains;
    }

    const sorted = allStables.peggedAssets
      .filter(a => a.circulating?.peggedUSD > 0)
      .sort((a, b) => b.circulating.peggedUSD - a.circulating.peggedUSD);
    const totalMarket = sorted.reduce((s, a) => s + a.circulating.peggedUSD, 0);

    const usdgEntry = sorted.find(a => a.id === USDG_ID);
    const pyusdEntry = sorted.find(a => a.id === PYUSD_ID);

    // Build combined history (aligned by date)
    const usdgMap = new Map(usdgHistory.map(p => [p.date, p.totalCirculating.peggedUSD]));
    const pyusdMap = new Map((pyusdHistory||[]).map(p => [p.date, p.totalCirculating.peggedUSD]));
    const allDates = [...new Set([...usdgMap.keys(), ...pyusdMap.keys()])].sort((a,b) => a - b);
    const combinedHistory = allDates.map(d => ({
      date: d,
      totalCirculating: { peggedUSD: (usdgMap.get(d) || 0) + (pyusdMap.get(d) || 0) }
    }));

    // Combined chains = merge both chain maps
    function mergeChains(a, b) {
      const merged = {};
      for (const [chain, data] of Object.entries(a)) {
        merged[chain] = { ...data };
      }
      for (const [chain, data] of Object.entries(b)) {
        if (merged[chain]) {
          merged[chain].current += data.current;
          if (data.prev30 && merged[chain].prev30) merged[chain].prev30 += data.prev30;
          if (data.prev7 && merged[chain].prev7) merged[chain].prev7 += data.prev7;
        } else {
          merged[chain] = { ...data };
        }
      }
      return merged;
    }

    const usdgChains = parseChains(usdgDetail);
    const pyusdChains = parseChains(pyusdDetail);

    // Combined entry for rankings simulation
    const combinedSupply = (usdgEntry?.circulating?.peggedUSD || 0) + (pyusdEntry?.circulating?.peggedUSD || 0);
    const combinedPrevDay = (usdgEntry?.circulatingPrevDay?.peggedUSD || 0) + (pyusdEntry?.circulatingPrevDay?.peggedUSD || 0);
    const combinedPrevWeek = (usdgEntry?.circulatingPrevWeek?.peggedUSD || 0) + (pyusdEntry?.circulatingPrevWeek?.peggedUSD || 0);
    const combinedPrevMonth = (usdgEntry?.circulatingPrevMonth?.peggedUSD || 0) + (pyusdEntry?.circulatingPrevMonth?.peggedUSD || 0);
    const combinedRank = sorted.filter(a => a.circulating.peggedUSD > combinedSupply).length + 1;

    // Milestone helper
    const milestoneTargets = [100e6, 250e6, 500e6, 750e6, 1e9];
    function getMilestones(history) {
      if (!history || !history.length) return milestoneTargets.map(() => null);
      const first = parseInt(history[0].date);
      return milestoneTargets.map(m => {
        const pt = history.find(p => p.totalCirculating.peggedUSD >= m);
        return pt ? Math.round((parseInt(pt.date) - first) / 86400) : null;
      });
    }

    const compareNames = Object.keys(COMPARE_STABLES);

    // Store everything
    DATA = {
      sorted, totalMarket, usdgEntry, pyusdEntry,
      usdgChains, pyusdChains,
      usdgHistory, pyusdHistory: pyusdHistory || [], combinedHistory,
      combinedSupply, combinedPrevDay, combinedPrevWeek, combinedPrevMonth, combinedRank,
      milestoneData: {
        'USDG': getMilestones(usdgHistory),
        'PYUSD': getMilestones(pyusdHistory),
        'Combined': getMilestones(combinedHistory),
      },
      compareHistories, compareNames,
    };
    compareHistories.forEach((h, i) => {
      if (h && h.length) DATA.milestoneData[compareNames[i]] = getMilestones(h);
    });

    render();

    // Toggle listeners
    document.getElementById('asset-toggle').addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      document.querySelectorAll('#asset-toggle button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      STATE.asset = btn.dataset.asset;
      render();
    });
    document.getElementById('period-toggle').addEventListener('click', e => {
      const btn = e.target.closest('button');
      if (!btn) return;
      document.querySelectorAll('#period-toggle button').forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      STATE.period = btn.dataset.period;
      render();
    });

    document.getElementById('updated-time').textContent = 'Live data, refreshed on page load. ' + new Date().toLocaleString();

  } catch (err) {
    console.error('Dashboard error:', err);
    document.getElementById('metrics-grid').innerHTML = '<div class="metric-card"><div class="label">Error</div><div class="value" style="font-size:1rem">Failed to load data. Check console.</div></div>';
  }
}

function render() {
  const { asset, period } = STATE;
  const { sorted, totalMarket, usdgEntry, pyusdEntry, usdgChains, pyusdChains,
    usdgHistory, pyusdHistory, combinedHistory,
    combinedSupply, combinedPrevDay, combinedPrevWeek, combinedPrevMonth, combinedRank,
    milestoneData } = DATA;

  const prevKey = period === '7d' ? 'circulatingPrevWeek' : 'circulatingPrevMonth';
  const periodLabel = period === '7d' ? '7 days' : '30 days';
  const color = ASSET_COLORS[asset];
  const assetLabel = asset === 'combined' ? 'USDG + PYUSD' : asset.toUpperCase();
  const assetIds = asset === 'usdg' ? [USDG_ID] : asset === 'pyusd' ? [PYUSD_ID] : [USDG_ID, PYUSD_ID];

  // Resolve current asset's data
  let supply, prevDay, prevWeek, prevMonth, rank, history, chains;
  if (asset === 'usdg') {
    supply = usdgEntry.circulating.peggedUSD;
    prevDay = usdgEntry.circulatingPrevDay?.peggedUSD || supply;
    prevWeek = usdgEntry.circulatingPrevWeek?.peggedUSD || supply;
    prevMonth = usdgEntry.circulatingPrevMonth?.peggedUSD || supply;
    rank = sorted.indexOf(usdgEntry) + 1;
    history = usdgHistory;
    chains = usdgChains;
  } else if (asset === 'pyusd') {
    supply = pyusdEntry.circulating.peggedUSD;
    prevDay = pyusdEntry.circulatingPrevDay?.peggedUSD || supply;
    prevWeek = pyusdEntry.circulatingPrevWeek?.peggedUSD || supply;
    prevMonth = pyusdEntry.circulatingPrevMonth?.peggedUSD || supply;
    rank = sorted.indexOf(pyusdEntry) + 1;
    history = pyusdHistory;
    chains = pyusdChains;
  } else {
    supply = combinedSupply;
    prevDay = combinedPrevDay; prevWeek = combinedPrevWeek; prevMonth = combinedPrevMonth;
    rank = combinedRank;
    history = combinedHistory;
    chains = {};
    // merge chains
    for (const [c, d] of Object.entries(usdgChains)) { chains[c] = { ...d }; }
    for (const [c, d] of Object.entries(pyusdChains)) {
      if (chains[c]) {
        chains[c].current += d.current;
        if (d.prev30 !== undefined && chains[c].prev30 !== undefined) chains[c].prev30 += d.prev30;
        if (d.prev7 !== undefined && chains[c].prev7 !== undefined) chains[c].prev7 += d.prev7;
      } else { chains[c] = { ...d }; }
    }
  }

  const prevPeriod = period === '7d' ? prevWeek : prevMonth;
  const dayDelta = prevDay > 0 ? ((supply - prevDay) / prevDay * 100) : 0;
  const periodDelta = prevPeriod > 0 ? ((supply - prevPeriod) / prevPeriod * 100) : 0;

  // ── Metrics cards ──
  document.getElementById('metrics-grid').innerHTML = `
    <div class="metric-card">
      <div class="label">Total Supply</div>
      <div class="value">${fmt(supply)}</div>
      <div class="delta ${dayDelta >= 0 ? 'up' : 'down'}">${pct(dayDelta)} (24h)</div>
    </div>
    <div class="metric-card">
      <div class="label">${asset === 'combined' ? 'Effective Rank' : 'Stablecoin Rank'}</div>
      <div class="value">#${rank}</div>
      <div class="delta neutral">${asset === 'combined' ? 'if treated as one asset' : 'of ' + sorted.length + ' stablecoins'}</div>
    </div>
    <div class="metric-card">
      <div class="label">${period} Change</div>
      <div class="value" style="color:${periodDelta >= 0 ? 'var(--green)' : 'var(--red)'}">${pct(periodDelta)}</div>
      <div class="delta ${periodDelta >= 0 ? 'up' : 'down'}">${fmt(Math.abs(supply - prevPeriod))}</div>
    </div>
    <div class="metric-card">
      <div class="label">Market Share</div>
      <div class="value">${(supply / totalMarket * 100).toFixed(2)}%</div>
      <div class="delta neutral">of ${fmt(totalMarket)} total</div>
    </div>
  `;

  // ── Insight ──
  const ins1 = document.getElementById('insight-1');
  if (history && history.length) {
    const age = Math.round((Date.now()/1000 - parseInt(history[0].date)) / 86400);
    const assetMilestones = milestoneData[asset === 'combined' ? 'Combined' : asset.toUpperCase()];
    const usdcTo1B = milestoneData['USDC']?.[4];
    const thisTo1B = assetMilestones?.[4];
    const speedFactor = (usdcTo1B && thisTo1B) ? (usdcTo1B / thisTo1B).toFixed(1) : null;
    ins1.style.display = 'block';
    ins1.innerHTML = `${assetLabel} is <strong>${age} days old</strong>, ranked #${rank} with <strong>${fmt(supply)}</strong> in circulation.${speedFactor ? ` Reached $1B roughly <strong>${speedFactor}x faster</strong> than USDC.` : ''}`;
  } else {
    ins1.style.display = 'none';
  }

  // ── Race to next rank ──
  const raceSection = document.getElementById('race-section');
  // Find what's directly above in rankings
  const effectiveRank = rank;
  if (effectiveRank > 1) {
    raceSection.style.display = '';
    // For combined, we need to find who's above the combined supply
    let aboveEntry;
    if (asset === 'combined') {
      aboveEntry = sorted.find(a => a.circulating.peggedUSD > supply && !assetIds.includes(a.id));
      // actually find the one just above
      const aboveAll = sorted.filter(a => a.circulating.peggedUSD > supply);
      aboveEntry = aboveAll[aboveAll.length - 1]; // closest one above
    } else {
      aboveEntry = sorted[effectiveRank - 2];
    }
    if (aboveEntry) {
      const gap = aboveEntry.circulating.peggedUSD - supply;
      const abovePct = (supply / aboveEntry.circulating.peggedUSD * 100);
      document.getElementById('race-subtitle').textContent =
        `${assetLabel} (#${effectiveRank}) vs ${aboveEntry.symbol} (#${sorted.indexOf(aboveEntry)+1})`;
      document.getElementById('race-track').innerHTML = `
        <div class="race-bar" style="width:${abovePct}%;background:${color}88;z-index:2;color:var(--fg);">
          ${assetLabel} ${fmt(supply)}
        </div>
        <div class="race-bar" style="width:100%;background:rgba(247,118,142,0.2);z-index:1;justify-content:flex-end;color:var(--red);">
          ${aboveEntry.symbol} ${fmt(aboveEntry.circulating.peggedUSD)}
        </div>`;
      let gapHtml = fmt(gap) + ' to overtake';
      if (history && history.length >= 7) {
        const recent = history.slice(-7);
        const dailyRate = (recent[recent.length-1].totalCirculating.peggedUSD - recent[0].totalCirculating.peggedUSD) / 7;
        if (dailyRate > 0) {
          gapHtml += `<br><span style="font-size:0.8rem;color:var(--gray)">~${daysStr(Math.ceil(gap / dailyRate))} at current 7d pace</span>`;
        }
      }
      document.getElementById('race-gap').innerHTML = gapHtml;
    }
  } else {
    raceSection.style.display = 'none';
  }

  // ── Supply chart ──
  destroyChart('supply');
  if (history && history.length) {
    const datasets = [];
    if (asset === 'combined') {
      // Show all three lines
      const usdgMap = new Map(usdgHistory.map(p => [p.date, p.totalCirculating.peggedUSD]));
      const pyusdMap = new Map(pyusdHistory.map(p => [p.date, p.totalCirculating.peggedUSD]));
      datasets.push({
        label: 'Combined', data: history.map(d => d.totalCirculating.peggedUSD),
        borderColor: ASSET_COLORS.combined, backgroundColor: ASSET_COLORS.combined + '14',
        fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2,
      });
      datasets.push({
        label: 'USDG', data: history.map(d => usdgMap.get(d.date) || 0),
        borderColor: ASSET_COLORS.usdg, backgroundColor: 'transparent',
        fill: false, tension: 0.3, pointRadius: 0, borderWidth: 1.5,
      });
      datasets.push({
        label: 'PYUSD', data: history.map(d => pyusdMap.get(d.date) || 0),
        borderColor: ASSET_COLORS.pyusd, backgroundColor: 'transparent',
        fill: false, tension: 0.3, pointRadius: 0, borderWidth: 1.5,
      });
    } else {
      datasets.push({
        label: assetLabel, data: history.map(d => d.totalCirculating.peggedUSD),
        borderColor: color, backgroundColor: color + '14',
        fill: true, tension: 0.3, pointRadius: 0, borderWidth: 2,
      });
    }
    charts['supply'] = new Chart(document.getElementById('supply-chart').getContext('2d'), {
      type: 'line',
      data: { labels: history.map(d => new Date(d.date * 1000)), datasets },
      options: {
        responsive: true,
        plugins: {
          legend: { display: asset === 'combined', labels: { color: '#565f89' } },
          tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + fmt(ctx.parsed.y) } }
        },
        scales: {
          x: { type: 'time', time: { unit: 'month' }, grid: { color: '#292e43' }, ticks: { color: '#565f89' } },
          y: { grid: { color: '#292e43' }, ticks: { color: '#565f89', callback: v => fmt(v) } }
        }
      }
    });
  }

  // ── Milestone chart ──
  destroyChart('milestone');
  const milestoneKey = asset === 'combined' ? 'Combined' : asset.toUpperCase();
  const milestoneColors = { 'USDG': '#7aa2f7', 'PYUSD': '#bb9af7', 'Combined': '#9ece6a', 'USDC': '#2775CA', 'USDe': '#9ece6a' };
  // Show current asset + comparisons
  const milestoneEntries = [[milestoneKey, milestoneData[milestoneKey]]];
  for (const name of Object.keys(COMPARE_STABLES)) {
    if (milestoneData[name]) milestoneEntries.push([name, milestoneData[name]]);
  }
  const milestoneTargets = [100e6, 250e6, 500e6, 750e6, 1e9];
  document.getElementById('milestone-title').textContent = `Speed to $1B: ${assetLabel} vs The Field`;
  charts['milestone'] = new Chart(document.getElementById('milestone-chart').getContext('2d'), {
    type: 'bar',
    data: {
      labels: milestoneTargets.map(m => fmt(m)),
      datasets: milestoneEntries.map(([name, vals]) => ({
        label: name, data: vals,
        backgroundColor: (milestoneColors[name] || '#565f89') + '99',
        borderColor: milestoneColors[name] || '#565f89', borderWidth: 1,
      }))
    },
    options: {
      responsive: true,
      plugins: {
        legend: { labels: { color: '#565f89' } },
        tooltip: { callbacks: { label: ctx => ctx.dataset.label + ': ' + (ctx.parsed.y !== null ? daysStr(ctx.parsed.y) : 'N/A') } }
      },
      scales: {
        x: { grid: { color: '#292e43' }, ticks: { color: '#565f89' } },
        y: { grid: { color: '#292e43' }, ticks: { color: '#565f89', callback: v => daysStr(v) },
          title: { display: true, text: 'Days', color: '#565f89' } }
      }
    }
  });
  const mi = document.getElementById('milestone-insight');
  const thisTo1B = milestoneData[milestoneKey]?.[4];
  const usdcTo1B = milestoneData['USDC']?.[4];
  if (thisTo1B && usdcTo1B) {
    mi.style.display = 'block';
    mi.innerHTML = `${assetLabel} reached <strong>$1B in ${daysStr(thisTo1B)}</strong>. USDC took <strong>${daysStr(usdcTo1B)}</strong>, making ${assetLabel} roughly <strong>${(usdcTo1B/thisTo1B).toFixed(1)}x faster</strong>.`;
  } else { mi.style.display = 'none'; }

  // ── Chain bars ──
  const chainContainer = document.getElementById('chain-bars');
  chainContainer.innerHTML = '';
  document.getElementById('chain-subtitle').textContent = `Where ${assetLabel} lives and where it's growing.`;
  const sortedChains = Object.entries(chains).filter(([,d]) => d.current > 0).sort((a,b) => b[1].current - a[1].current);
  const maxChain = sortedChains[0]?.[1].current || 1;
  const chainTotal = sortedChains.reduce((s,[,d]) => s + d.current, 0);

  for (const [chain, data] of sortedChains) {
    const pctOfTotal = (data.current / chainTotal * 100).toFixed(1);
    const barPct = (data.current / maxChain * 100).toFixed(1);
    const clr = CHAIN_COLORS[chain] || '#7dcfff';
    let deltaHtml = '';
    const prevChain = period === '7d' ? data.prev7 : data.prev30;
    if (prevChain && prevChain > 0) {
      const rate = ((data.current - prevChain) / prevChain * 100);
      deltaHtml = `<span class="chain-delta delta ${rate >= 0 ? 'up' : 'down'}">${pct(rate)} ${period}</span>`;
    }
    chainContainer.innerHTML += `
      <div class="chain-bar">
        <div class="chain-name">${chain}</div>
        <div class="bar-track"><div class="bar-fill" style="width:${barPct}%;background:${clr}"></div></div>
        <div class="bar-meta">${fmt(data.current)} (${pctOfTotal}%)<br>${deltaHtml}</div>
      </div>`;
  }

  const ci = document.getElementById('chain-insight');
  const prevChainKey = period === '7d' ? 'prev7' : 'prev30';
  const fastest = sortedChains
    .filter(([,d]) => d[prevChainKey] && d[prevChainKey] > 0)
    .map(([name, d]) => [name, ((d.current - d[prevChainKey]) / d[prevChainKey] * 100)])
    .sort((a,b) => b[1] - a[1])[0];
  if (fastest) {
    ci.style.display = 'block';
    ci.innerHTML = `<strong>${fastest[0]}</strong> is the fastest-growing chain at <strong>${pct(fastest[1])}</strong> over ${periodLabel}.${
      sortedChains[0][0] !== fastest[0] ? ` Meanwhile, <strong>${sortedChains[0][0]}</strong> holds the most supply.` : ''
    }`;
  } else { ci.style.display = 'none'; }

  // ── Alt-stable share ──
  destroyChart('altShare');
  const bigTwo = sorted.slice(0, 2).reduce((s, a) => s + a.circulating.peggedUSD, 0);
  const altMarket = totalMarket - bigTwo;
  const altShare = (supply / altMarket * 100);
  document.getElementById('alt-subtitle').textContent = `${assetLabel}'s share of non-USDT/USDC stablecoins`;
  charts['altShare'] = new Chart(document.getElementById('alt-share-chart').getContext('2d'), {
    type: 'doughnut',
    data: {
      labels: [assetLabel, 'Other alt-stables'],
      datasets: [{ data: [supply, altMarket - supply], backgroundColor: [color, '#292e43'], borderColor: [color, '#565f89'], borderWidth: 1 }]
    },
    options: {
      responsive: true, cutout: '65%',
      plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => ctx.label + ': ' + fmt(ctx.parsed) } } }
    },
    plugins: [{
      id: 'centerText',
      afterDraw(chart) {
        const { ctx, chartArea: { width, height, top, left } } = chart;
        ctx.save();
        ctx.fillStyle = '#c0caf5';
        ctx.font = 'bold 1.3rem "IBM Plex Mono", monospace';
        ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(altShare.toFixed(1) + '%', left + width/2, top + height/2 - 8);
        ctx.font = '0.7rem "IBM Plex Mono", monospace';
        ctx.fillStyle = '#565f89';
        ctx.fillText('of alt-stables', left + width/2, top + height/2 + 14);
        ctx.restore();
      }
    }]
  });

  // ── Growth rate vs peers ──
  destroyChart('growth');
  const pd = sorted
    .filter(a => a.circulating.peggedUSD > 500e6 && a[prevKey]?.peggedUSD > 0)
    .map(a => ({
      symbol: a.symbol, id: a.id,
      rate: ((a.circulating.peggedUSD - a[prevKey].peggedUSD) / a[prevKey].peggedUSD * 100),
      isTarget: assetIds.includes(a.id),
    }))
    .sort((a, b) => b.rate - a.rate)
    .slice(0, 12);
  document.getElementById('growth-subtitle').textContent = `${period} growth rate, stablecoins >$500M`;
  charts['growth'] = new Chart(document.getElementById('growth-chart').getContext('2d'), {
    type: 'bar',
    data: {
      labels: pd.map(d => d.isTarget ? d.symbol + ' ◀' : d.symbol),
      datasets: [{
        data: pd.map(d => d.rate),
        backgroundColor: pd.map(d => d.isTarget ? color : '#292e43'),
        borderColor: pd.map(d => d.isTarget ? color : '#565f89'),
        borderWidth: 1,
      }]
    },
    options: {
      indexAxis: 'y', responsive: true,
      plugins: { legend: { display: false }, tooltip: { callbacks: { label: ctx => pct(ctx.parsed.x) } } },
      scales: {
        x: { grid: { color: '#292e43' }, ticks: { color: '#565f89', callback: v => pct(v) } },
        y: { grid: { display: false }, ticks: {
          color: ctx => pd[ctx.index]?.isTarget ? color : '#565f89',
          font: ctx => ({ weight: pd[ctx.index]?.isTarget ? 'bold' : 'normal' })
        } }
      }
    }
  });

  // ── Growth capture ──
  destroyChart('capture');
  const growthData = sorted
    .filter(a => a[prevKey]?.peggedUSD > 0)
    .map(a => ({
      symbol: a.symbol, id: a.id,
      growth: a.circulating.peggedUSD - a[prevKey].peggedUSD,
      isTarget: assetIds.includes(a.id),
    }))
    .filter(a => a.growth > 0)
    .sort((a, b) => b.growth - a.growth)
    .slice(0, 10);
  const totalPosGrowth = growthData.reduce((s, a) => s + a.growth, 0);
  const capCI = document.getElementById('capture-insight');
  document.getElementById('capture-subtitle').textContent = `${period}: when the market grows, where do new dollars go?`;

  if (growthData.length > 0) {
    // Ensure target assets in top 6
    const targetInTop = growthData.slice(0, 6).some(d => d.isTarget);
    let top6 = growthData.slice(0, 6);
    let rest = growthData.slice(6);
    if (!targetInTop) {
      const targetItem = growthData.find(d => d.isTarget);
      if (targetItem) {
        top6 = [...growthData.slice(0, 5), targetItem];
        rest = growthData.slice(5).filter(d => !d.isTarget);
      }
    }
    const otherGrowth = rest.reduce((s, d) => s + d.growth, 0);
    const pieData = [...top6];
    if (otherGrowth > 0) pieData.push({ symbol: 'Other', growth: otherGrowth, isTarget: false });

    const pieColors = pieData.map(d => {
      if (d.isTarget) return color;
      const palette = ['#f7768e','#e0af68','#9ece6a','#7dcfff','#bb9af7','#ff9e64','#565f89'];
      return palette[pieData.indexOf(d) % palette.length];
    });

    charts['capture'] = new Chart(document.getElementById('capture-chart').getContext('2d'), {
      type: 'doughnut',
      data: {
        labels: pieData.map(d => d.symbol),
        datasets: [{ data: pieData.map(d => d.growth), backgroundColor: pieColors, borderColor: '#1a1b26', borderWidth: 2 }]
      },
      options: {
        responsive: true, cutout: '45%',
        plugins: {
          legend: { position: 'right', labels: { color: '#c0caf5', font: { size: 11 }, padding: 12 } },
          tooltip: { callbacks: { label: ctx => ctx.label + ': ' + fmt(ctx.parsed) + ' (' + (ctx.parsed/totalPosGrowth*100).toFixed(1) + '%)' } }
        }
      }
    });

    // Sum target assets' growth for insight
    const targetGrowth = growthData.filter(d => d.isTarget).reduce((s, d) => s + d.growth, 0);
    if (targetGrowth > 0) {
      capCI.style.display = 'block';
      capCI.innerHTML = `Of all stablecoins that grew in the last ${periodLabel}, ${assetLabel} captured <strong>${(targetGrowth/totalPosGrowth*100).toFixed(1)}%</strong> of new supply (<strong>${fmt(targetGrowth)}</strong>).`;
    } else { capCI.style.display = 'none'; }
  } else {
    capCI.style.display = 'block';
    capCI.innerHTML = `The stablecoin market contracted over the last ${periodLabel}.`;
  }

  // ── Market table ──
  document.getElementById('table-period-header').textContent = period;
  const tbody = document.getElementById('market-tbody');
  tbody.innerHTML = '';
  const top20 = sorted.slice(0, 20);
  let targetInTable = false;
  for (const s of top20) {
    const mcap = s.circulating.peggedUSD;
    const share = (mcap / totalMarket * 100);
    const prev = s[prevKey]?.peggedUSD || mcap;
    const change = prev > 0 ? ((mcap - prev) / prev * 100) : 0;
    const isTarget = assetIds.includes(s.id);
    if (isTarget) targetInTable = true;
    const idx = sorted.indexOf(s) + 1;
    tbody.innerHTML += `<tr class="${isTarget ? 'highlight-row' : ''}">
      <td>${idx}. ${s.symbol}</td>
      <td>${fmt(mcap)}</td>
      <td class="delta ${change >= 0 ? 'up' : 'down'}">${pct(change)}</td>
      <td>${share.toFixed(2)}%</td>
    </tr>`;
  }
  if (!targetInTable) {
    // Add target rows
    for (const id of assetIds) {
      const entry = sorted.find(a => a.id === id);
      if (!entry) continue;
      const mcap = entry.circulating.peggedUSD;
      const share = (mcap / totalMarket * 100);
      const prev = entry[prevKey]?.peggedUSD || mcap;
      const change = prev > 0 ? ((mcap - prev) / prev * 100) : 0;
      const idx = sorted.indexOf(entry) + 1;
      tbody.innerHTML += `<tr class="highlight-row">
        <td>${idx}. ${entry.symbol}</td>
        <td>${fmt(mcap)}</td>
        <td class="delta ${change >= 0 ? 'up' : 'down'}">${pct(change)}</td>
        <td>${share.toFixed(2)}%</td>
      </tr>`;
    }
  }
}

main();

// ── Dune Analytics on-chain data ──
let DUNE_DATA = null;
async function loadDuneData() {
  try {
    const res = await fetch('/data/dune.json');
    if (!res.ok) throw new Error('HTTP ' + res.status);
    DUNE_DATA = await res.json();
    document.getElementById('dune-section').style.display = '';
    if (DUNE_DATA.updated) {
      const dt = new Date(DUNE_DATA.updated);
      document.getElementById('dune-updated-at').textContent = 'Last updated ' + dt.toLocaleDateString('en-US', { month: 'short', day: 'numeric' }) + ' at ' + dt.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' }) + '.';
    }
    renderDune();
  } catch (err) {
    console.warn('Dune data unavailable:', err.message);
  }
}

function renderDune() {
  if (!DUNE_DATA?.data) return;
  const { asset, period } = STATE;
  const d = DUNE_DATA.data;
  const color = ASSET_COLORS[asset];
  const assetLabel = asset === 'combined' ? 'USDG + PYUSD' : asset.toUpperCase();
  const is7d = period === '7d';
  const wantUSDG = asset === 'usdg' || asset === 'combined';
  const wantPYUSD = asset === 'pyusd' || asset === 'combined';

  // Collect all summary rows from ALL chains (evm_summary + sol_summary)
  const summaryKeys = Object.keys(d).filter(k => k.endsWith('_summary'));
  const allSummary = summaryKeys.flatMap(k => Array.isArray(d[k]) ? d[k] : []);
  // Filter to selected asset(s)
  const relevant = allSummary.filter(r =>
    (wantUSDG && r.token === 'USDG') || (wantPYUSD && r.token === 'PYUSD')
  );
  let holders = 0, activeAddrs = 0, transfers = 0, volume = 0;
  for (const r of relevant) {
    holders += r.holders || 0;
    activeAddrs += is7d ? (r.active_7d || 0) : (r.active_30d || 0);
    transfers += is7d ? (r.transfers_7d || 0) : (r.transfers_30d || 0);
    volume += is7d ? (r.volume_7d || 0) : (r.volume_30d || 0);
  }
  // Chain breakdown for subtitle
  const chainBreakdown = relevant.map(r => `${r.token} on ${r.chain}`).join(', ');

  const grid = document.getElementById('dune-metrics-grid');
  grid.innerHTML = `
    ${holders ? `<div class="metric-card">
      <div class="label">Holders (Ethereum)</div>
      <div class="value">${holders.toLocaleString()}</div>
      <div class="delta neutral">unique addresses with balance</div>
    </div>` : ''}
    <div class="metric-card">
      <div class="label">Active Addresses (${period})</div>
      <div class="value">${activeAddrs.toLocaleString()}</div>
      <div class="delta neutral">${chainBreakdown || 'across chains'}</div>
    </div>
    <div class="metric-card">
      <div class="label">Transfers (${period})</div>
      <div class="value">${transfers.toLocaleString()}</div>
    </div>
    <div class="metric-card">
      <div class="label">Transfer Volume (${period})</div>
      <div class="value">${fmt(volume)}</div>
    </div>
  `;

  // ── Daily volume chart ──
  destroyChart('volume');
  // Merge all daily data from ALL chains
  const dailyKeys = Object.keys(d).filter(k => k.endsWith('_daily'));
  const allDaily = dailyKeys.flatMap(k => Array.isArray(d[k]) ? d[k] : [])
    .filter(r => (wantUSDG && r.token === 'USDG') || (wantPYUSD && r.token === 'PYUSD'));

  // Aggregate by date
  const dailyMap = new Map();
  for (const r of allDaily) {
    const key = r.day.split(' ')[0];
    const existing = dailyMap.get(key) || { day: key, volume_m: 0, transfers: 0 };
    existing.volume_m += (r.volume_m || 0);
    existing.transfers += (r.transfers || 0);
    dailyMap.set(key, existing);
  }
  const dailyData = [...dailyMap.values()].sort((a,b) => a.day.localeCompare(b.day));

  if (dailyData.length > 0) {
    charts['volume'] = new Chart(document.getElementById('volume-chart').getContext('2d'), {
      type: 'bar',
      data: {
        labels: dailyData.map(r => new Date(r.day)),
        datasets: [{
          label: 'Volume',
          data: dailyData.map(r => r.volume_m || 0),
          backgroundColor: color + '66',
          borderColor: color,
          borderWidth: 1,
        }]
      },
      options: {
        responsive: true,
        plugins: {
          legend: { display: false },
          tooltip: { callbacks: { label: ctx => fmt(ctx.parsed.y) } }
        },
        scales: {
          x: { type: 'time', time: { unit: 'week' }, grid: { color: '#292e43' }, ticks: { color: '#565f89' } },
          y: { grid: { color: '#292e43' }, ticks: { color: '#565f89', callback: v => fmt(v) } }
        }
      }
    });
  }

  // ── Whale concentration ──
  destroyChart('whale');
  const whaleSection = document.getElementById('whale-section');
  const whaleKeys = Object.keys(d).filter(k => k.endsWith('_whales'));
  const allWhales = whaleKeys.flatMap(k => Array.isArray(d[k]) ? d[k] : []);
  const whaleData = allWhales.filter(r =>
    (wantUSDG && r.token === 'USDG') || (wantPYUSD && r.token === 'PYUSD')
  );
  if (whaleData.length > 0) {
    whaleSection.style.display = '';
    const tokens = [...new Set(whaleData.map(r => r.token))];
    const whaleChains = [...new Set(whaleData.map(r => r.chain))];
    document.getElementById('whale-subtitle').textContent = `Top holders on ${whaleChains.join(', ')}: ${tokens.join(' & ')}`;
    const multiContext = tokens.length > 1 || whaleChains.length > 1;
    const labels = whaleData.map(r => (multiContext ? r.token + '/' + r.chain + ' ' : '') + r.address.slice(0, 6) + '...' + r.address.slice(-4));
    const barColors = whaleData.map(r => r.token === 'USDG' ? ASSET_COLORS.usdg : ASSET_COLORS.pyusd);
    charts['whale'] = new Chart(document.getElementById('whale-chart').getContext('2d'), {
      type: 'bar',
      data: {
        labels,
        datasets: [{
          data: whaleData.map(r => r.pct),
          backgroundColor: barColors.map(c => c + '66'),
          borderColor: barColors,
          borderWidth: 1,
        }]
      },
      options: {
        indexAxis: 'y', responsive: true,
        plugins: { legend: { display: false }, tooltip: {
          callbacks: { label: ctx => whaleData[ctx.dataIndex].token + ' ' + whaleData[ctx.dataIndex].address + ': ' + fmt(whaleData[ctx.dataIndex].balance) + ' (' + ctx.parsed.x.toFixed(1) + '%)' }
        }},
        scales: {
          x: { grid: { color: '#292e43' }, ticks: { color: '#565f89', callback: v => v.toFixed(0) + '%' } },
          y: { grid: { display: false }, ticks: { color: '#565f89', font: { size: 10 } } }
        }
      }
    });
    // Insight per token
    const wi = document.getElementById('whale-insight');
    const insights = [];
    for (const token of tokens) {
      for (const chain of whaleChains) {
        const tw = whaleData.filter(r => r.token === token && r.chain === chain);
        if (!tw.length) continue;
        const top10 = tw.slice(0, 10).reduce((s,r) => s + r.pct, 0);
        insights.push(`Top 10 ${token} holders on ${chain} control <strong>${top10.toFixed(1)}%</strong> of supply.`);
      }
    }
    wi.style.display = 'block';
    wi.innerHTML = insights.join(' ');
  } else {
    whaleSection.style.display = 'none';
  }

  // ── DEX trading ──
  const dexSection = document.getElementById('dex-section');
  const allDex = Array.isArray(d.dex_volume) ? d.dex_volume : [];
  const dexData = allDex.filter(r =>
    (wantUSDG && r.token === 'USDG') || (wantPYUSD && r.token === 'PYUSD')
  );
  if (dexData.length > 0) {
    dexSection.style.display = '';
    const dexBars = document.getElementById('dex-bars');
    dexBars.innerHTML = '';
    const maxVol = dexData[0]?.volume_30d || 1;
    for (const row of dexData.slice(0, 12)) {
      const barPct = (row.volume_30d / maxVol * 100).toFixed(1);
      const barColor = row.token === 'USDG' ? ASSET_COLORS.usdg : ASSET_COLORS.pyusd;
      dexBars.innerHTML += `
        <div class="chain-bar">
          <div class="chain-name" style="width:140px">${row.token} / ${row.project}</div>
          <div class="bar-track"><div class="bar-fill" style="width:${barPct}%;background:${barColor}"></div></div>
          <div class="bar-meta" style="width:180px">${fmt(row.volume_30d)}<br><span style="font-size:0.72rem;color:var(--gray)">${row.token_pair} (${row.trades.toLocaleString()} trades)</span></div>
        </div>`;
    }
  } else {
    dexSection.style.display = 'none';
  }
}

// Hook Dune re-render into toggle changes
const origRender = render;
render = function() {
  origRender();
  if (DUNE_DATA) { try { renderDune(); } catch(e) { console.warn('Dune render error:', e); } }
};

loadDuneData();
    </script>
  </body>
</html>
